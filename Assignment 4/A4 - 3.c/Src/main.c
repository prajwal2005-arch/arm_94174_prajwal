/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#include <stdint.h>

/* Base addresses */
#define RCC_BASE        0x40023800
#define GPIOA_BASE      0x40020000
#define GPIOD_BASE      0x40020C00

/* RCC register */
#define RCC_AHB1ENR     (*(volatile uint32_t *)(RCC_BASE + 0x30))

/* GPIOA (Switch) */
#define GPIOA_MODER     (*(volatile uint32_t *)(GPIOA_BASE + 0x00))
#define GPIOA_PUPDR     (*(volatile uint32_t *)(GPIOA_BASE + 0x0C))
#define GPIOA_IDR       (*(volatile uint32_t *)(GPIOA_BASE + 0x10))

/* GPIOD (LEDs) */
#define GPIOD_MODER     (*(volatile uint32_t *)(GPIOD_BASE + 0x00))
#define GPIOD_ODR       (*(volatile uint32_t *)(GPIOD_BASE + 0x14))

/* Bit positions */
#define RCC_GPIOA_EN    (1 << 0)
#define RCC_GPIOD_EN    (1 << 3)

#define SWITCH_PIN     0      // PA0
#define GREEN_LED      12     // PD12
#define BLUE_LED       15     // PD15

/* Simple delay */
void delay(volatile uint32_t d)
{
    while (d--);
}

int main(void)
{
    uint8_t press_count = 0;

    /* Enable GPIO clocks */
    RCC_AHB1ENR |= (RCC_GPIOA_EN | RCC_GPIOD_EN);

    /* PA0 as input */
    GPIOA_MODER &= ~(3 << (SWITCH_PIN * 2));

    /* Pull-down for PA0 */
    GPIOA_PUPDR &= ~(3 << (SWITCH_PIN * 2));
    GPIOA_PUPDR |=  (2 << (SWITCH_PIN * 2));

    /* PD12 & PD15 as output */
    GPIOD_MODER &= ~(3 << (GREEN_LED * 2));
    GPIOD_MODER |=  (1 << (GREEN_LED * 2));

    GPIOD_MODER &= ~(3 << (BLUE_LED * 2));
    GPIOD_MODER |=  (1 << (BLUE_LED * 2));

    while (1)
    {
        /* Detect switch press */
        if (GPIOA_IDR & (1 << SWITCH_PIN))
        {
            delay(50000);   // debounce

            press_count++;

            if (press_count == 1)
            {
                /* 1st press: Green ON */
                GPIOD_ODR |= (1 << GREEN_LED);
                GPIOD_ODR &= ~(1 << BLUE_LED);
            }
            else if (press_count == 2)
            {
                /* 2nd press: Blue ON */
                GPIOD_ODR |= (1 << BLUE_LED);
                GPIOD_ODR &= ~(1 << GREEN_LED);
            }
            else if (press_count == 3)
            {
                /* 3rd press: Both OFF */
                GPIOD_ODR &= ~(1 << GREEN_LED);
                GPIOD_ODR &= ~(1 << BLUE_LED);
                press_count = 0;   // reset cycle
            }

            /* Wait until switch released */
            while (GPIOA_IDR & (1 << SWITCH_PIN));
            delay(50000);
        }
    }
}
